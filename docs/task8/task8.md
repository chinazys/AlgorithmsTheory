# Умова завдання

## Задача 1

Згенерувати випадкову послідовність цілих чисел. Елементи послідовності зберігти в BST, використовуючи звичайний метод
вставки. При дублюванні ключів вставку виконувати не треба (тобто всі значення ключів у дереві вийдуть унікальними).
Відобразити на екрані вихідну послідовність та отримане дерево.

Ввести з клавіатури число k. Видалити з дерева елемент із ключем k та відобразити змінене дерево. Виконувати ці дії до
введення числа 100.

Ввести з клавіатури число m. Видалити з дерева елемент із порядковим номером m, відобразити змінене дерево.
Виконувати ці дії до введення числа 100.Вивести всі дані, що зберігаються в BST, у вигляді впорядкованої послідовності.

## Задача 2

Згенерувати послідовність цілих чисел, що зростають.

Елементи послідовності зберігти в BST, використовуючи звичайний метод вставки. Відобразити дерево на екрані.

Елементи послідовності зберегти в новому BST, використовуючи метод вставки в корінь. Відобразити дерево на екрані.

# Задача 1

## Постановка задачі:
Реалізувати бінарне пошукове дерево з можливістю вставки елементу, видалення елементу за ключем, видалення елементу за індексом
## Умови експерименту: 
1. Згенерувати випадкову послідовність цілих чисел.

2. Вставити елементи послідовності в бінарне дерево пошуку (BST), використовуючи звичайний метод вставки.

3. При дублюванні ключів вставку не виконувати, тобто всі значення ключів у дереві повинні бути унікальними.

4. Відобразити на екрані вихідну послідовність та отримане дерево.

5. Ввести з клавіатури число k.

6. Видалити з дерева елемент з ключем k та відобразити змінене дерево.

7. Повторювати ці дії до введення числа 100.

8. Ввести з клавіатури число m.

9. Видалити з дерева елемент з порядковим номером m та відобразити змінене дерево.

10. Повторювати ці дії до введення числа 100.

11. Вивести всі дані, що зберігаються в BST, у вигляді впорядкованої послідовності.
## Результати:
    
    Random sequence: [10, 2, 4, 9, 1, 8, 7, 6, 3, 5]
    Binary Search Tree*: { (1; 1) <- (2; 9) -> (3; 1) <- (4; 7) -> (5; 1) <- (6; 2) <- (7; 3) <- (8; 4) <- (9; 5) <- (10; 10) }

    Modified BST after deleting element with key 6:
    { (1; 1) <- (2; 8) -> (3; 1) <- (4; 6) -> (5; 1) <- (7; 2) <- (8; 3) <- (9; 4) <- (10; 9) }

    Modified BST after deleting element with key 4:
    { (1; 1) <- (2; 7) -> (3; 5) -> (5; 1) <- (7; 2) <- (8; 3) <- (9; 4) <- (10; 8) }

    Modified BST after deleting element with index 1:
    { (2; 6) -> (3; 5) -> (5; 1) <- (7; 2) <- (8; 3) <- (9; 4) <- (10; 7) }

    Modified BST after deleting element with index 4:
    { (2; 5) -> (3; 4) -> (5; 1) <- (8; 2) <- (9; 3) <- (10; 6) }

    * (a, b) -> Tree node with key = a and subtree length of b
## Висновок: 
1. Проведено вставку випадкової послідовності цілих чисел у бінарне дерево пошуку (BST) з використанням звичайного методу вставки.
2. Після вставки елементів отримане дерево відображено на екрані.
3. Здійснено видалення елементів за ключем k та за порядковим номером m з дерева. Після кожного видалення змінене дерево відображено на екрані.
4. Виведено всі дані, що зберігаються в BST, у вигляді впорядкованої послідовності.
5. За результатами дослідження можна стверджувати, що вставка та видалення елементів у BST працюють правильно та забезпечують коректну структуру дерева.

# Задача 2
## Постановка задачі:
Реалізувати бінарне пошукове дерево з додатковою можливістю вставки елементу в корінь
## Умови експерименту: 
1. Згенерувати послідовність цілих чисел.
2. Вставити елементи послідовності в бінарне дерево пошуку (BST), використовуючи звичайний метод вставки.
3. Відобразити дерево на екрані.
4. Створити нове бінарне дерево пошуку (BST).
5. Вставити елементи послідовності в нове дерево, використовуючи метод вставки в корінь.
6. Відобразити нове дерево на екрані.

## Результати: 

    Ascending sequence: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    BST Leaf Insertion*: { (1; 10) -> (2; 9) -> (3; 8) -> (4; 7) -> (5; 6) -> (6; 5) -> (7; 4) -> (8; 3) -> (9; 2) -> (10; 1) }
    BST Root Insertion*: { (1; 1) <- (2; 2) <- (3; 3) <- (4; 4) <- (5; 5) <- (6; 6) <- (7; 7) <- (8; 8) <- (9; 9) <- (10; 10) }
    
    * (a, b) -> Tree node with key = a and subtree length of b
## Висновки:
1. Згенеровано послідовність цілих чисел, що зростають.
2. Послідовність чисел було вставлено у бінарне дерево пошуку (BST) за допомогою звичайного методу вставки. Відповідне дерево було відображено на екрані.
3. Створено нове бінарне дерево пошуку (BST) та вставлено в нього послідовність чисел, використовуючи метод вставки в корінь. Відповідне дерево було відображено на екрані.
4. За результатами дослідження можна стверджувати, що методи вставки в звичайний порядок та вставки в корінь коректно працюють і забезпечують правильну структуру дерева.